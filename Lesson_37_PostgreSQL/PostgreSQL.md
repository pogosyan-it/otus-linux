# PostgreSQL
Установка PostgreSQL из пакетов, а также сборка из исходного кода, должны выполнятся в соответствии с офф. документацией:
Полезные ссылки:  
<https://www.postgresql.org/download/> <br/>
<https://postgrespro.ru/education/courses/DBA1/>

## Tips and FAQs

# Подключение в БД postgres
1) После устаноки подключится к БД:  
   psql -d postgres (создается пользователь с правми superuser и бд postgres)
2) C внешних серверов:  
   `psql -d база -U роль -h узел -p порт ` 
 
 Чтобы дать разрешение на подключение с удаленных хостов к бд, необходимо:
 1) прописать в файл postgresql.conf  
    `listen_addresses = '*'`, если нужно конкретную подсеть указать, вместо * пишем 192.168.0.0/24 
 2) В файл pg_hba.conf прописать:  
    `host     mybd     postgres     192.168.0.0/24     md5`  
    Запись разрешает подключение к БД mybd пользователю postgres с подсети 192.168.0.0/24, используя пароль.
Узнать расположение файлов конфигурации PostgreSQL: postgresql.conf, pg_hba.conf:  
`ps aux | grep postgres | grep -- -D`  
Для получения информация о текущем подключении:  
`postgres-# \conninfo`  
You are connected to database "postgres" as user "postgres" via socket in "/var/run/postgresql" at port "5432".  
# Создание пользователя  
`CREATE USER user WITH PASSWORD 'mypassword';`
Чтобы подключится к базе под этим пользователем в системе должен быть создан рользователь с таким именем и в файл pg_hba.conf прописано разрешение (см выше)  
Создание пользователя с правами суперпользователя:  
`create user my_user with superuser password 'mypass';`  
Выдать все права для пользователя `user_name` на БД `myDB`:  
`GRANT ALL PRIVILEGES on DATABASE "myDB" to my_user`;
Создать базу данных:  
`Create database myDB;`
Изменение пароля пользователя:  
`ALTER USER MyUser WITH PASSWORD 'NEW_PASS';`
Выдать права роли myrole на вход в БД  
`ALTER ROLE myrole WITH LOGIN;`  

# Мета команды
`\c new_db` сменить базу данных  
`\dt` список таблиц  
`\l` список баз  
`\u` список пользователей  
`\f` список функций  
`\?` - СПРАВКА  
`\dt public.*` - список таблиц в схеме.  

# Схемы  
Кластер баз данных — это набор баз данных, которыми управляет один экземпляр сервера. Понятие кластеров баз данных было введено разработчиками OS Ubuntu для упрощения работы с PostgreSQL, для этого был собран специальный пакет postgres-common.
Схема базы данных — это коллекция объектов базы данных, имеющая одного владельца и формирующая одно пространство имен. Две таблицы в одной и той же схеме не могут иметь одно и то же имя.
База данных содержит одну (по умолчанию существует схема public) или несколько именованных схем, которые, в свою очередь, содержат таблицы. Схемы также содержат именованные объекты других видов, включая типы данных, функции и операторы. Одно и то же имя объекта можно свободно использовать в разных схемах, например, и schema1, и myschema могут содержать таблицы с именем mytable.  
   В отличие от баз данных схемы не ограничивают доступ к данным: пользователи могут обращаться к объектам в любой схеме текущей базы данных, если им назначены соответствующие права.
   Есть несколько возможных объяснений, для чего стоит применять схемы:

    Чтобы одну базу данных могли использовать несколько пользователей, независимо друг от друга.
    Чтобы объединить объекты базы данных в логические группы для облегчения управления ими.
    Чтобы в одной базе сосуществовали разные приложения, и при этом не возникало конфликтов имен.  
Схемы в некоторым смысле подобны каталогам в операционной системе, но они не могут быть вложенными.  
Для создания схемы используется команда CREATE SCHEMA. 
`CREATE SCHEMA schema_name;`
Cоздать таблицу в новой схеме можно так:
`CREATE TABLE myschema.mytable (
 ...);`  
Cоздать схему, владельцем которой будет другой пользователь:  
 `CREATE SCHEMA schema_name AUTHORIZATION user_name;`
Список всех схем в бд, схемы которые начинаются с `pg_` - это служебные схемы бд  
 `select * from information_schema.schemata;`  
Важно отметить, что в postgres, для того, чтобы не писать полное имя таблицы `my_schema.my_table` по умолчанию используется путь поиска:  

 `SHOW search_path;`  
 `-----------------`  
 `"$user", public`  
 `(1 row)`  

Как видно, если опустить в запросе имя схемы, то поиск будет происходить именно в схеме по умолчанию - public.  
Чтобы добавить в путь нашу новую схему, мы выполняем:  
`SET search_path TO myschema,public;`
# Схемы и права
Выдать права на использование схемы public пользователю user.  
`GRANT USAGE on SCHEMA "public" to user;`  
Выдать для роли myrole права SELECT на вновь создаваемые таблицы пользователем user в схеме public.  
`ALTER DEFAULT PRIVILEGES FOR USER user IN SCHEMA public GRANT SELECT ON TABLES TO myrole;`  
Выдайте права для user только на SELECT из всех таблиц в схеме public  
`GRANT SELECT ON ALL TABLES IN SCHEMA public  TO user;`  

<https://lk.rebrainme.com/postgresql/task/597>  

# Представления, Функции и Триггеры.  
Представления или View используются для удобаства, когда один и тот же запрос необходимо использовать много раз. По сути птакому запросу присваивается имя и созраняется в базу данных. Обращение к такому представлению осуществляется так же как и к обычной таблице:  
`CREATE VIEW view_name AS  
    SELECT ...;`  
В Postgres существует огромное кол-во **встроенных функций** - мат. функции, строковые, функции даты и времени, подробно о которых можно почитать:  
<https://postgrespro.ru/docs/postgresql/13/functions>  
Например:  
` SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00');`  
 `------------`  
 `1372680000`  
 `(1 row)`  
 `select to_timestamp(1372680000);`  
  `    to_timestamp`  
  `------------------------`  
  `2013-07-01 12:00:00+00`  
  
**Оконные функции** используется для обработки результата запроса. Окно — это некоторое выражение, описывающее набор строк, которые будет обрабатывать функция и порядок этой обработки. Причем окно может быть просто задано пустыми скобками (), т.е. *окном являются все строки результата запроса*.  
`Select course_id, coursename, tasks_count,  sum(price) OVER () FROM courses;`  
Запрос выведет дополнительный столбец в каждой строке которого будет сумма всех значений столбца `price`  
Если добавить в предыдущий запрос `OVER (ORDER BY price)`, то будет в каждой ячейке стобца будет вписана сумма предыдущих значений поля `price`:  
`Select course_id, coursename, tasks_count,  price, sum(price) OVER (ORDER BY price) FROM courses;`  
` course_id | coursename | tasks_count | price |  sum`  
`-----------+------------+-------------+-------+--------`  
`         3 | Bash       |          15 |  6900 |   6900`  
`         8 | Logs       |          14 |  7900 |  14800`   
`         9 | Postgresql |          14 | 10000 |  24800`  

**Пользовательские функции** бывают 4 типов:  
  Функции на языке запросов (функции, написанные на SQL) - <https://postgrespro.ru/docs/postgresql/13/xfunc-sql>
  Функции на процедурных языках (функции, написанные, например, на PL/pgSQL или PL/Tcl) - <https://postgrespro.ru/docs/postgresql/13/xfunc-pl>
  Внутренние функции - <https://postgrespro.ru/docs/postgresql/13/xfunc-internal>
  Функции на языке C - <https://postgrespro.ru/docs/postgresql/13/xfunc-c>  
  Пример функции написаной на языке SQL:  
  CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;



